<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Java Concurrency Flashcards</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background: #f0f2f5; }
        .card-container { perspective: 1000px; width: 400px; height: 250px; margin: 50px; cursor: pointer; }
        .card { position: relative; width: 100%; height: 100%; text-align: center; transition: transform 0.6s; transform-style: preserve-3d; }
        .card.flipped { transform: rotateY(180deg); }
        .front, .back { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; padding: 20px; border-radius: 15px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); box-sizing: border-box; }
        .front { background: #fff; color: #333; font-weight: bold; font-size: 1.2rem; }
        .back { background: #007bff; color: white; transform: rotateY(180deg); font-size: 1rem; }
        .controls { margin-top: 20px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; border: none; border-radius: 5px; background: #333; color: white; margin: 5px; }
        button:hover { background: #555; }
    </style>
</head>
<body>
    <h1>Java Concurrency Flashcards (8-21)</h1>
    <div class="card-container" onclick="this.querySelector('.card').classList.toggle('flipped')">
        <div class="card" id="card">
            <div class="front" id="card-front">Click "Next" to start!</div>
            <div class="back" id="card-back">...</div>
        </div>
    </div>
    <div class="controls">
        <button onclick="prevCard()">Previous</button>
        <button onclick="shuffleCards()">Shuffle & Restart</button>
        <button onclick="nextCard()">Next</button>
    </div>

    <script>
        const cards = [
            { q: "What is a Virtual Thread?", a: "A lightweight thread managed by the JVM (Java 21) that allows scaling to millions of concurrent tasks with low overhead." },
            { q: "What is Structured Concurrency?", a: "A model where subtasks are syntactically bound to their parent task, ensuring all children finish before the parent (Java 21)." },
            { q: "Explain 'Optimistic Reading' in StampedLock.", a: "A mode where a thread reads without a full lock, checking later if the version 'stamp' changed. Faster if contention is low." },
            { q: "Difference between 'Runnable' and 'Callable'?", a: "Runnable returns void and cannot throw checked exceptions; Callable returns a value and can throw exceptions." },
            { q: "What is a 'Livelock'?", a: "A situation where threads keep changing states in response to each other but never progress (like two people dodging in a hallway)." },
            { q: "What is the 'Double-Checked Locking' pitfall?", a: "Without 'volatile', another thread might see a partially initialized singleton object due to reordering." },
            { q: "How to prevent Deadlock by Lock Ordering?", a: "Always acquire multiple locks in the same global order (e.g., sort accounts by ID before locking)." }
        ];

        let currentIndex = 0;
        let deck = [...cards];

        function displayCard() {
            document.getElementById('card').classList.remove('flipped');
            setTimeout(() => {
                document.getElementById('card-front').innerText = deck[currentIndex].q;
                document.getElementById('card-back').innerText = deck[currentIndex].a;
            }, 150);
        }

        function nextCard() { currentIndex = (currentIndex + 1) % deck.length; displayCard(); }
        function prevCard() { currentIndex = (currentIndex - 1 + deck.length) % deck.length; displayCard(); }
        function shuffleCards() {
            deck.sort(() => Math.random() - 0.5);
            currentIndex = 0;
            displayCard();
        }
    </script>
</body>
</html>
